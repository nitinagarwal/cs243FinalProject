%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LaTeX Example: Project Report
%
% Source: http://www.howtotex.com
%
% Feel free to distribute this example, but please keep the referral
% to howtotex.com
% Date: March 2011 
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% How to use writeLaTeX: 
%
% You edit the source code here on the left, and the preview on the
% right shows you the result within a few seconds.
%
% Bookmark this page and share the URL with your co-authors. They can
% edit at the same time!
%
% You can upload figures, bibliographies, custom classes and
% styles using the files menu.
%
% If you're new to LaTeX, the wikibook is a great place to start:
% http://en.wikibooks.org/wiki/LaTeX
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Edit the title below to update the display in My Documents
%\title{Project Report}
%
%%% Preamble
\documentclass[paper=a4, fontsize=11pt]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage{fourier}

\usepackage[english]{babel}															% English language/hyphenation
\usepackage[protrusion=true,expansion=true]{microtype}	
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage[pdftex]{graphicx}	
\usepackage{url}


%%% Custom sectioning
\usepackage{sectsty}
\allsectionsfont{\centering \normalfont\scshape}


%%% Custom headers/footers (fancyhdr package)
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\fancyhead{}											% No page header
\fancyfoot[L]{}											% Empty 
\fancyfoot[C]{}											% Empty
\fancyfoot[R]{\thepage}									% Pagenumbering
\renewcommand{\headrulewidth}{0pt}			% Remove header underlines
\renewcommand{\footrulewidth}{0pt}				% Remove footer underlines
\setlength{\headheight}{13.6pt}


%%% Equation and float numbering
\numberwithin{equation}{section}		% Equationnumbering: section.eq#
\numberwithin{figure}{section}			% Figurenumbering: section.fig#
\numberwithin{table}{section}				% Tablenumbering: section.tab#


%%% Maketitle metadata
\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} 	% Horizontal rule

\title{
		%\vspace{-1in} 	
		\usefont{OT1}{bch}{b}{n}
		\normalfont \normalsize \textsc{School of Computer Science} \\ 
        \normalsize \textsc{High Performance Architecture (COMPSCI 243)} \\
        [25pt]
		\horrule{0.5pt} \\[0.4cm]
		\huge GPU Benchmarking Report \\
		\horrule{2pt} \\[0.5cm]
}
\author{
		\normalfont 								
        \normalsize
        Zahra Montazeri \\[-3pt]		
        \normalsize 
        \newline
        \normalsize
        Nitin Agarwal \\[-3pt]		
        \normalsize 
        \newline
        \newline
        \today
}
\date{}
\newpage

%%% Begin document
\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\section{Vision and Scope}
In this project, a set of well-defined test cases for the GPU have been established. This test is used to compare the performance across platforms with different graphics cards. The main focus is to benchmark some parameters of same test cases on different graphic cards. For comparison we did benchmark on three different NVIDIA cards and profile some parameters using nvprof as profiling tool. We have the results as well as analysis on the results at the end of this documentation.\\
First we searched for GPU programs and performed them on Linux. All benchmarks have been performed using the release 3.1 version of the Rodinia. Later in this report we have the more detail description of these programs.\\
We used nvporf as NVIDIA profiling tool which is a command-line profiler available for Linux, Windows, and OS X. It helps user to understand and optimize the performance of the CUDA application and easily compare and analyze the result of one benchmark on different GPUs.
CUDA 7.5 is the version which we used for all three graphic cards in this project.\\
There are some parameters in which we compared and analyzed within these three  different graphic cards. Calculating execution time is the first parameter we experimented and compare how different NVIDIA cards run same programs. We also consider number of kernel calls and API calls in each program and compare this factor with different machine as well. The percentage of heat released by the program and using fan is another two factors we have covered in this benchmarking. We can also see on which GPU each kernel ran, as well as the grid dimensions used for each launch. Gridsize is Number of blocks in a grid along the X and Y dimensions for a kernel launch. This is very useful when we want to verify that a multi-GPU application is running as we expect. But in this profiling the applications are running just on one GPU. The last but not least parameter we considered for comparing and analysis is regs of each program which is number of registers used per thread for a kernel launch.\\

\newpage
\section{Methodology}
\subsection{GPU Parallelisation}
The GPU computing approach uses graphic card to perform the calculation in parallel. This approach is based on CUDA which is made by NVIDIA and works on NVIDIA graphic cards that have Compute Capability 2.0 or higher. The point is worth mentioning that only hydrodynamic calculations are performed on the GPU and the additional calculations are ran on the CPU. Then these calculations are parallelised using shared memory approach, OpenMP.


\subsection{Hardware}
Following are the graphic cards which we used for performing benchmarks:\\
\newline
\begin{tabular}{|l| c| c| c|}
	\hline
	GPU & Compute 
Capability & Number of CUDA cores & Memory (GB)\\
	\hline
    GeForce GT 630 & 2.1 & 96 & 1.8  \\
	\hline
    Geforce GTX 650 & 3.0 & 384 & 5 \\
	\hline
    Quadro 6000 & 2.0 & 448 & 6 \\
	\hline
\end{tabular}
\\
GPU specifications
\\
\\
following hardware platforms have been used:\\
\newline
\begin{tabular}{| c| c| c| c|}
	\hline
	  & Processor & Memory (GB)& Operating system\\
	\hline
    1  & Intel Xeon(R) E5405 (4 cores, 2.00GHz) & 2& ubuntu 14.04 \\
	\hline
    2  & XXX & XXX& ubuntu 14.04 \\
	\hline
    3  & Intel Core 2 Quad Q9400 (4 cores, 2.66GHz) & 7.8& ubuntu 14.04 \\
	\hline
\end{tabular}
\\
Hardware platforms

\subsection{Software}
All benchmarks have been performed using the release 3.1 version of the Rodinia: accelerating Compute-Intensive Applications with Accelerators. It released to address some concerns in  which platforms face. For example, there are many suites for parallel computing on general-purpose CPU architectures, but accelerators fall into a gap that is not covered by previous benchmark development.
\newpage
\section{Description of Benchmarks}
Here are brief description for all of the benchmarks we used in this project.

\subsection{Breadth First Search}
Graph algorithms are fundamental and widely used in many disciplines and application areas. Large graphs involving millions of vertices are common in scientific and engineering applications. This benchmark suite provides the GPU implementations of breadth-first search (BFS) algorithm which traverses all the connected components in a graph.

\subsection{K-Nearest Neighbor}
NN (Nearest Neighbor) finds the k-nearest neighbors from an unstructured data set. The sequential NN algorithm reads in one record at a time, calculates the Euclidean distance from the target latitude and longitude, and evaluates the k nearest neighbors. The parallel versions read in many records at a time, execute the distance calculation on multiple threads, and the master thread updates the list of nearest neighbors.

\subsection{B+Tree}
B+ Tree application has many internal commands that maintain database and process querries. Only J and K commands had enough parallelism to be ported to parallel languages (OpenMP, CUDA, OpenCL). In these implementations, in case of both J and K, the same algorithms (optimized for exposing fine-grained parallelism) were used for fair comparison purposes. For C/OpenMP execution, it is possible to use the original algorithm.

\subsection{PathFinder}
PathFinder uses dynamic programming to find a path on a 2-D grid from the bottom row to the top row with the smallest accumulated weights, where each step of the path moves straight ahead or diagonally ahead. It iterates row by row, each node picks a neighboring node in the previous row that has the smallest accu- mulated weight, and adds its own weight to the sum.
This kernel uses the technique of ghost zone optimization.

\subsection{LU Decomposition}
LU Decomposition is an algorithm to calculate the solutions of a set of linear equations. The LUD kernel decomposes a matrix as the product of a lower triangular matrix and an upper triangular matrix.

\subsection{Gaussian Elimination}
Gaussian Elimination computes result row by row, solving for all of the variables in a linear system. The algorithm must synchronize between iterations, but the values calculated in each iteration can be computed in parallel.

\subsection{hotspot}
HotSpot is a widely used tool to estimate processor temperature based on an architectural floorplan and simulated power measurements. The thermal simulation iteratively solves a series of differential equations for block. Each output cell in the computational grid represents the average temperature value of the corresponding area of the chip. Our CUDA implementation re-implements the transient thermal differential equation solver from HotSpot.

\newpage
\section{Benchmarking using a GeForce GT 630}
These tests have been performed using a GeForce GT 630 and hardware platform 1 specified in the table in section 2.2.
\newpage
\section{Benchmarking using a GeForce GTX 650}
These tests have been performed using a GeForce GTX 650 and hardware platform 2 specified in the table in section 2.2.

\newpage
\section{Benchmarking using a Quadro 6000}
These tests have been performed using a Quadro 6000 and hardware platform 3 specified in the table in section 2.2.
\newpage
\section{Results}
\newpage
\section{Analysis}
\newpage
\section{Conclusion}
\newpage
\section{References}

%%% End document
\end{document}